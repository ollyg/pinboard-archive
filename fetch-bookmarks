#!/usr/bin/perl

# Requires the urw-fonts package (or perhaps better) to render fonts nicely

use warnings;
use strict;

use Data::Dumper;
use File::Spec::Functions qw(catfile);
use IO::Interactive qw(is_interactive);
use WWW::Pinboard;

# Define some output files
my $log_filename    = "log.txt";
my $error_filename  = "errorlog.txt";
my $retry_filename  = "retry.txt";
my $failed_filename = "failed.txt";

my $last_fetch_filename = "last-fetch";
my $output_folder = 'output';

my $DEBUG = 0;

start();

sub start {
    my $token = "";
    my $api = WWW::Pinboard->new(token => $token);

    # Check the output folder exists
    check_output_folder($output_folder);

    # Retry previously failed URLs
    retry_failed_urls($api);
    exit;

    # Lookup last time bookmarks were fetched
    my $last_fetch = get_last_fetch();
    print "Last recorded fetch was $last_fetch\n";

    # Get all bookmarks created since last fetch
    my $bookmarks = get_bookmarks_since($api, $last_fetch);
    print Dumper $bookmarks if $DEBUG;

    # Archive bookmarks!
    archive_bookmark($_) for @$bookmarks;
}

# Check output folder exists, create it if not
sub check_output_folder {
    my $output_folder = shift;

    mkdir $output_folder unless (-d $output_folder);
}

# Lookup the last bookmark we fetched using the log file
sub get_last_fetch {
    open(my $last_fetch_fh, '<', $last_fetch_filename);
    my $last_fetch = <$last_fetch_fh>;
    return $last_fetch || 0;
}

# Store the last bookmark fetched in a log file
sub set_last_fetch {
    my $last_updated = shift;

    open(my $last_fetch_fh, '>', $last_fetch_filename);
    print $last_fetch_fh $last_updated;
}

# Get bookmarks since $date from earliest to latest
sub get_bookmarks_since {
    my $api = shift;
    my $from_date = shift;

    my $bookmarks = $api->all(fromdt => $from_date);

    $bookmarks = [ reverse @$bookmarks ];

    return $bookmarks;
}

# Archives a bookmark using the defined methods, then marks it as fetched
sub archive_bookmark {
    my $bookmark = shift;

    print "Fetching \"", shortname($bookmark), "\"\n";
    std_log("Archiver", Dumper $bookmark);

    archive_as_image($bookmark);
    #archive_as_pdf($bookmark);

    # No need to fetch it again
    set_last_fetch($bookmark->{time});

    # If we're running interactively, make it easier to cancel with Ctrl+C
    sleep(1) if is_interactive();
}

# Archive bookmark as an image using wkhtmltoimage
sub archive_as_image {
    my $bookmark = shift;

    print "  Archiving as image...\n";

    my $url = $bookmark->{href};
    my $filename = catfile($output_folder, $bookmark->{hash} . ".png");

    my $wk_cmd = "wkhtmltoimage";
    my $wk_flags = "--quiet --quality 89"; # quality >89 gives huge filesizes
    my $wk_out = ">/dev/null 2>&1";

    my $wk_full = join(' ', $wk_cmd, $wk_flags, bash_encode($url), $filename, $wk_out);
    std_log("wkImage", "Using: '$wk_full'");

    # Run and check response code
    my $rc;
    # This will catch wkhtmls that take longer than 2 minutes, but they'll stick around as zombies
    eval {
        local $SIG{ALRM} = sub { die "alarm\n" };
        alarm 240; # four minute timeout

        $rc = system($wk_full);

        alarm 0;
    };
    if ($@) {
        # wkhtml timed out, log it
        die unless $@ eq "alarm\n";
        print "    [Fetch timed out]\n";
        error_log("wkImage", "*** Fetch timed out for $filename");

        # Retry again later
        retry_log("$url");

        return;
    }

    # wkhtml didn't time out, check return code
    std_log("wkImage", "Response code was $rc");

    # Retry later if a non-zero exit code
    retry_log("$url") if $rc;

    if ($rc == 256) {
        error_log("wkImage", "*** Possible error $rc for $filename ($url)") if $rc;
        print "    [Possible error ($rc)]\n" if $rc;
    }
    else {
        error_log("wkImage", "*** Respose code was $rc for $filename ($url)") if $rc;
        print "    [Operation may have failed ($rc)]\n" if $rc;
    }
}

# Archive bookmark as a PDF using wkhtmltopdf
sub archive_as_pdf {
    my $bookmark = shift;

    print "  Archiving as pdf...\n";

    my $url = bash_encode($bookmark->{href});
    my $filename = catfile($output_folder, $bookmark->{hash} . ".pdf");

    my $wk_cmd = "wkhtmltopdf";
    my $wk_flags = "--quiet"; # --quiet
    my $wk_out = ">/dev/null 2>&1";

    my $wk_full = join(' ', $wk_cmd, $wk_flags, $url, $filename, $wk_out);
    std_log("wkPDF", "Using: '$wk_full'");

    # Run and check response code
    my $rc = system($wk_full);
    std_log("wkImage", "Response code was $rc");
    error_log("wkPDF", "*** Respose code was $rc for $filename ($url)") if $rc;
    print "    [Operation may have failed ($rc)]\n" if $rc;
}

# Return a string that is "safe" for bash
sub bash_encode {
    my $string = shift;

    return '"' . $string . '"';
}

# Returns a pretty truncated bookmark description
sub shortname {
    my $bookmark = shift;

    my $shortname = substr($bookmark->{description}, 0, 65);
    $shortname .= "..." if (length $bookmark->{description} > 65);

    return $shortname;
}

sub std_log {
    my $section = shift;
    my $message = shift;

    my $type = "log";

    write_log($type, $section, $message);
}

sub error_log {
    my $section = shift;
    my $message = shift;

    my $type = "error";

    write_log($type, $section, $message);
}

sub retry_log {
    my $message = shift;

    my $type    = "retry";
    my $section = "";

    write_log($type, $section, $message);
}

# Do logging
#   Standard log: system() commands being run, bookmark dump
#   Error log: any problems - fetch timeouts, bad return codes
#   Retry log: any urls that we should retry. How should you read/edit/write this though?
sub write_log {
    my $type = shift;
    my $section = shift;
    my $message = shift;
    chomp $message;

    my $pretty = 1;

    # Work out where to send the log message
    my $log_fh;
    if ($type eq "log") {
        open($log_fh, '>>', $log_filename);
    }
    elsif ($type eq "error") {
        open($log_fh, '>>', $error_filename);
    }
    elsif ($type eq "retry") {
        open($log_fh, '>>', $retry_filename);
        $pretty = 0;
    }
    else {
        die "Unknown log type";
    }

    # Decide if we want a pretty formatted output
    if ($pretty) {
        print $log_fh "[$section]: $message\n";
    }
    else {
        print $log_fh "$message\n";
    }
}
