#!/usr/bin/perl

use warnings;
use strict;

use Data::Dumper;
use File::Spec::Functions qw(catfile);
use WWW::Pinboard;

# Define some output files
my $log_filename = "log.txt";
my $error_filename = "errorlog.txt";
my $last_fetch_filename = "last-fetch";
my $output_folder = 'output';

my $DEBUG = 1;

my $token;
my $api = WWW::Pinboard->new(token => $token);

check_output_folder($output_folder);

my $last_fetch = get_last_fetch();
print "Last recorded fetch was $last_fetch\n";

my $bookmarks = get_bookmarks_since($last_fetch);
print Dumper $bookmarks if $DEBUG;

for my $bookmark (@$bookmarks) {
    archive_bookmark($bookmark);
}

# Check output folder exists, create it if not
sub check_output_folder {
    my $output_folder = shift;

    mkdir $output_folder unless (-d $output_folder);
}

# Lookup the last bookmark we fetched using the log file
sub get_last_fetch {
    open(my $last_fetch_fh, '<', $last_fetch_filename);
    my $last_fetch = <$last_fetch_fh>;
    return $last_fetch || 0;
}

# Store the last bookmark fetched in a log file
sub set_last_fetch {
    my $last_updated = shift;

    open(my $last_fetch_fh, '>', $last_fetch_filename);
    print $last_fetch_fh $last_updated;
}

# Get bookmarks since $date from earliest to latest
sub get_bookmarks_since {
    my $from_date = shift;

    my $bookmarks = $api->all(fromdt => $from_date);

    $bookmarks = [ reverse @$bookmarks ];

    return $bookmarks;
}

# Archives a bookmark using the defined methods, then marks it as fetched
sub archive_bookmark {
    my $bookmark = shift;

    print "Fetching \"", shortname($bookmark), "\"\n";
    std_log("Archiver", Dumper $bookmark) if $DEBUG;

    archive_as_image($bookmark);
    archive_as_pdf($bookmark);

    # No need to fetch it again
    set_last_fetch($bookmark->{time});

    sleep(1);
}

# Archive bookmark as an image using wkhtmltoimage
sub archive_as_image {
    my $bookmark = shift;

    print "  Archiving as image...\n";

    my $url = bash_encode($bookmark->{href});
    my $filename = catfile($output_folder, $bookmark->{hash} . ".png");

    my $wk_cmd = "wkhtmltoimage";
    my $wk_flags = "--quiet --quality 89"; # quality >89 gives huge filesizes
    my $wk_out = ">/dev/null 2>&1";

    my $wk_full = join(' ', $wk_cmd, $wk_flags, $url, $filename, $wk_out);
    std_log("wkImage", "Using: '$wk_full'");

    # Run and check response code
    my $rc;

    # The script will continue, but you'll have issues with zombie wkhtmls
    # This will catch wkhtmls that take longer than 2 minutes, but they'll stick around as zombies
    eval {
        local $SIG{ALRM} = sub { die "alarm\n" };
        alarm 240; # four minute timeout

        $rc = system($wk_full);

        alarm 0;
    };
    if ($@) {
        # wkhtml timed out, log it
        die unless $@ eq "alarm\n";
        print "    [Fetch timed out]\n";
        error_log("wkImage", "*** Fetch timed out for $filename");
    }
    else {
        # wkhtml didn't time out, check return code
        std_log("wkImage", "Response code was $rc");
        error_log("wkImage", "*** Respose code was $rc for $filename ($url)") if $rc;
        print "    [Operation may have failed ($rc)]\n" if $rc;
    }
}

# Archive bookmark as a PDF using wkhtmltopdf
sub archive_as_pdf {
    my $bookmark = shift;

    print "  Archiving as pdf...\n";

    my $url = bash_encode($bookmark->{href});
    my $filename = catfile($output_folder, $bookmark->{hash} . ".pdf");

    my $wk_cmd = "wkhtmltopdf";
    my $wk_flags = "--quiet"; # --quiet
    my $wk_out = ">/dev/null 2>&1";

    my $wk_full = join(' ', $wk_cmd, $wk_flags, $url, $filename, $wk_out);
    std_log("wkPDF", "Using: '$wk_full'");

    # Run and check response code
    my $rc = system($wk_full);
    std_log("wkImage", "Response code was $rc");
    error_log("wkPDF", "*** Respose code was $rc for $filename ($url)") if $rc;
    print "    [Operation may have failed ($rc)]\n" if $rc;
}

# Return a string that is "safe" for bash
sub bash_encode {
    my $string = shift;

    return '"' . $string . '"';
}

# Returns a pretty truncated bookmark description
sub shortname {
    my $bookmark = shift;

    my $shortname = substr($bookmark->{description}, 0, 65);
    $shortname .= "..." if (length $bookmark->{description} > 65);

    return $shortname;
}

sub std_log {
    my $section = shift;
    my $message = shift;

    my $type = "log";

    write_log($type, $section, $message);
}

sub error_log {
    my $section = shift;
    my $message = shift;

    my $type = "error";

    write_log($type, $section, $message);
}

sub write_log {
    my $type = shift;
    my $section = shift;
    my $message = shift;
    chomp $message;

    my $log_fh;
    if ($type eq "log") {
        open($log_fh, '>>', $log_filename);
    }
    elsif ($type eq "error") {
        open($log_fh, '>>', $error_filename);
    }
    else {
        warn "Unknown log type";
    }

    print $log_fh "[$section]: $message\n";
}
