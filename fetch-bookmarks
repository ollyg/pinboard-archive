#!/usr/bin/perl

# Requires the urw-fonts package (or perhaps better) to render fonts nicely

use warnings;
use strict;

use Data::Dumper;
use File::Spec::Functions qw(catfile);
use IO::Interactive qw(is_interactive);
use Tie::Persistent;
use WWW::Pinboard;

# Define some output files
my $log_filename    = "log.txt";
my $error_filename  = "errorlog.txt";
my $retry_filename  = "retry.db";
my $failed_filename = "failed.txt";

my $last_fetch_filename = "last-fetch";
my $output_folder = 'output';

my $DEBUG = 0;

start();

sub start {
    my $token = "";
    my $api = WWW::Pinboard->new(token => $token);

    # Check the output folder exists
    check_output_folder($output_folder);

    # Retry previously failed URLs
    retry_failed_urls($api);

    # Lookup last time bookmarks were fetched
    my $last_fetch = get_last_fetch();
    print "Last recorded fetch was $last_fetch\n";

    # Get all bookmarks created since last fetch
    my $bookmarks = get_bookmarks_since($api, $last_fetch);
    print Dumper $bookmarks if $DEBUG;

    # Archive bookmarks!
    archive_bookmark($_) for @$bookmarks;
}

# Check output folder exists, create it if not
sub check_output_folder {
    my $output_folder = shift;

    mkdir $output_folder unless (-d $output_folder);
}

# Lookup the timestamp of the last bookmark we fetched
sub get_last_fetch {
    open(my $last_fetch_fh, '<', $last_fetch_filename);
    my $last_fetch = <$last_fetch_fh>;
    return $last_fetch || 0;
}

# Store the timestamp of the last bookmark we fetched
sub set_last_fetch {
    my $last_updated = shift;

    open(my $last_fetch_fh, '>', $last_fetch_filename);
    print $last_fetch_fh $last_updated;
}

# Get bookmarks since $date from earliest to latest
sub get_bookmarks_since {
    my $api = shift;
    my $from_date = shift;

    my $bookmarks = $api->all(fromdt => $from_date);

    $bookmarks = [ reverse @$bookmarks ];

    return $bookmarks;
}

# Get a bookmark object from a URL
# Returns the first bookmark in search results
# What happens if there's nothing to return?
sub get_bookmark_from_url {
    my $api = shift;
    my $url = shift;

    my $response = $api->get(url => $url);
    my $bookmark = $response->{posts}->[0];

    return $bookmark;
}

# Archives a bookmark, record the return code and update the last_fetch timestamp
sub archive_bookmark {
    my $bookmark = shift;

    print "Fetching \"", shortname($bookmark), "\"\n";
    std_log("Archiver", "Archiving '" . shortname($bookmark) . "' ($bookmark->{href})");
    std_log("Archiver", Dumper $bookmark) if $DEBUG;

    my $rc = archive_as_image($bookmark);

    # check return code and log URL to retry later
    log_fetched_url($bookmark->{href}, $rc);

    # No need to fetch it again
    set_last_fetch($bookmark->{time});

    print "\n";

    # If we're running interactively, make it easier to cancel with Ctrl+C
    sleep(1) if is_interactive();

    return $rc;
}

# Retry all the URLs in retry.db
sub retry_failed_urls {
    my $api = shift;

    print "Retrying failed URLs:\n\n";
    std_log("Retry", "Retrying failed URLs");

    # Open retry database, take a copy, then close the file
    # Avoids clashing with other code that accesses the file
    tie my %RETRY, 'Tie::Persistent', $retry_filename, 'rw';
    my %retry = %RETRY;
    untie %RETRY;

    for my $url (keys %retry) {
        if ($retry{$url} < 3) {
            print "Retrying $url (attempt $retry{$url})!\n";
            std_log("Retry", "Retrying (attempt $retry{$url}) $url");

            my $bookmark = get_bookmark_from_url($api, $url);
            archive_bookmark($bookmark);
        }
        else {
            print "Not retrying $url after $retry{$url} failures\n";
            std_log("Retry", "Not retrying (attempt $retry{$url}) $url");
        }
    }
}

# Archive bookmark as an image using wkhtmltoimage
# Returns 0 on total success, non-zero on partial or complete failure
sub archive_as_image {
    my $bookmark = shift;

    print "  Archiving as image...\n";

    my $url = $bookmark->{href};
    my $filename = catfile($output_folder, $bookmark->{hash} . ".png");

    my $wk_cmd = "wkhtmltoimage";
    my $wk_flags = "--quiet --quality 89"; # quality >89 gives huge filesizes
    my $wk_out = ">/dev/null 2>&1";

    my $wk_full = join(' ', $wk_cmd, $wk_flags, bash_encode($url), $filename, $wk_out);
    std_log("wkImage", "Using: '$wk_full'") if $DEBUG;

    # Run and check response code
    my $rc;
    # This will catch wkhtmls that take longer than 2 minutes, but they'll stick around as zombies
    eval {
        local $SIG{ALRM} = sub { die "alarm\n" };
        alarm 240; # four minute timeout

        $rc = system($wk_full);

        alarm 0;
    };
    if ($@) {
        # wkhtml timed out, log it
        die unless $@ eq "alarm\n";

        print "    [Fetch timed out]\n";
        error_log("wkImage", "*** Fetch timed out for $filename");

        return 1; # return non-zero exit code due to failure
    }

    # wkhtml didn't time out, check return code
    std_log("wkImage", "Response code was $rc");

    if ($rc == 256) {
        error_log("wkImage", "*** Possible error $rc for $filename ($url)") if $rc;
        print "    [Possible error ($rc)]\n" if $rc;
    }
    elsif ($rc != 0) {
        error_log("wkImage", "*** Respose code was $rc for $filename ($url)") if $rc;
        print "    [Operation may have failed ($rc)]\n" if $rc;
    }

    return $rc; # will return non-zero on failure
}

# Archive bookmark as a PDF using wkhtmltopdf
sub archive_as_pdf {
    my $bookmark = shift;

    print "  Archiving as pdf...\n";

    my $url = bash_encode($bookmark->{href});
    my $filename = catfile($output_folder, $bookmark->{hash} . ".pdf");

    my $wk_cmd = "wkhtmltopdf";
    my $wk_flags = "--quiet"; # --quiet
    my $wk_out = ">/dev/null 2>&1";

    my $wk_full = join(' ', $wk_cmd, $wk_flags, $url, $filename, $wk_out);
    std_log("wkPDF", "Using: '$wk_full'");

    # Run and check response code
    my $rc = system($wk_full);
    std_log("wkImage", "Response code was $rc");
    error_log("wkPDF", "*** Respose code was $rc for $filename ($url)") if $rc;
    print "    [Operation may have failed ($rc)]\n" if $rc;
}

# Log that we've fetched a URL
# Update retry.db depending on success/failure
sub log_fetched_url {
    my $url = shift;
    my $rc  = shift;

    my %RETRY;
    tie %RETRY, 'Tie::Persistent', $retry_filename, 'rw';
    (tied %RETRY)->autosync(1); # writeback on every modify

    if (! $rc) {
        delete $RETRY{$url};
    }
    else {
        $RETRY{$url}++;
    }
    untie %RETRY;
}


# Return a string that is "safe" for bash. Ish.
sub bash_encode {
    my $string = shift;

    return '"' . $string . '"';
}

# Returns a pretty truncated bookmark description
sub shortname {
    my $bookmark = shift;

    my $shortname = substr($bookmark->{description}, 0, 65);
    $shortname .= "..." if (length $bookmark->{description} > 65);

    return $shortname;
}

#
# Logging

sub std_log {
    my $section = shift;
    my $message = shift;

    my $type = "log";

    write_log($type, $section, $message);
}

sub error_log {
    my $section = shift;
    my $message = shift;

    my $type = "error";

    write_log($type, $section, $message);
}

# Do logging
#   Standard log: system() commands being run, bookmark dump
#   Error log: any problems - fetch timeouts, bad return codes
sub write_log {
    my $type = shift;
    my $section = shift;
    my $message = shift;
    chomp $message;

    # Work out where to send the log message
    my $log_fh;
    if ($type eq "log") {
        open($log_fh, '>>', $log_filename);
    }
    elsif ($type eq "error") {
        open($log_fh, '>>', $error_filename);
    }
    else {
        die "Unknown log type";
    }

    print $log_fh "[$section]: $message\n";
}
